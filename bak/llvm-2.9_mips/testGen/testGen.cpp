// Generated by llvm2cpp - DO NOT MODIFY!

#include <llvm/LLVMContext.h>
#include <llvm/Module.h>
#include <llvm/DerivedTypes.h>
#include <llvm/Constants.h>
#include <llvm/GlobalVariable.h>
#include <llvm/Function.h>
#include <llvm/CallingConv.h>
#include <llvm/BasicBlock.h>
#include <llvm/Instructions.h>
#include <llvm/InlineAsm.h>
#include <llvm/Support/FormattedStream.h>
#include <llvm/Support/MathExtras.h>
#include <llvm/Support/CommandLine.h>
#include <llvm/Pass.h>
#include <llvm/PassManager.h>
#include <llvm/ADT/SmallVector.h>
#include <llvm/Analysis/Verifier.h>
#include <llvm/Assembly/PrintModulePass.h>
#include <llvm/Bitcode/ReaderWriter.h>
#include "newDAGGen.h"
#include "AutoConfig.h"
#include "GraphAnalysis.h"
#include <algorithm>
using namespace llvm;

void usage(char * ex){
	cout << "Usage: " << "\n";
	cout << ex << " [Block cap] [inputNum] [outputNum] [depthFactor]\n";
	cout << "OR\n";
	cout << ex << " [Block cap] [inputNum] [outputNum] [depthFactor] [seed]\n";
}
int main(int argc, char**argv){
	std::string Err;
	cl::opt<string> ConfigFilename("config-file", cl::desc("Auto test case generation configuration filename"), cl::value_desc("filename"));
	//printf("Start!\n");
	cl::ParseCommandLineOptions(argc, argv);
	if(((string)ConfigFilename).length()==0){
		cout << "Please specify a configuration file" << endl;
		return 1;
	}
	cout << "configuration file name is " << ConfigFilename << "\n";

	//Load the configuration
	AutoConfig* ac = new AutoConfig(ConfigFilename);

	int seed;
	if(ac->has_seed){
		seed = ac->seed;
	}else{
		seed = seed = (unsigned) time(0);
	}
	cout << "Seed:" << seed << "\n";
	cout << "Input Number: " << ac->InputNum << "\n";
	cout << "Output Number: " << ac->OutputNum << "\n";
	cout << "BlockCap: " << ac->BBNum << "\n";
	cout << "depthFactor: " << ac->DepthFactor << "\n";
	cout << "useArrayInput: " << ac->useArrayInput << "\n";

	CFGGenerator* g = new CFGGenerator(ac->BBNum, seed, ac->InputNum, ac->OutputNum, 0, ac->DepthFactor, ac->useArrayInput, ac->enable_sub_funtion, ac);

	g->CFG_StartGenRand();
	char BB_DOT[30];
	sprintf(BB_DOT, "dfg_main1.dot");
	g->CFG_Ntk->vBBlock.at(2)->DFG_NtkGenerator->Ntk->print_ntk_to_dot(BB_DOT);
/*
	char BB_DOT[30];
	sprintf(BB_DOT, "dfg_main1.dot");
	g->CFG_Ntk->vBBlock.at(2)->DFG_NtkGenerator->Ntk->print_ntk_to_dot(BB_DOT);
	if(g->CFG_Ntk->vBBlock.size()>=4){
		char BB_DOT[30];
		sprintf(BB_DOT, "dfg_main3.dot");
		g->CFG_Ntk->vBBlock.at(3)->DFG_NtkGenerator->Ntk->print_ntk_to_dot(BB_DOT);
	}
	if(g->CFG_Ntk->vBBlock.size()>=5){
		char BB_DOT[30];
		sprintf(BB_DOT, "dfg_main4.dot");
		g->CFG_Ntk->vBBlock.at(4)->DFG_NtkGenerator->Ntk->print_ntk_to_dot(BB_DOT);
	}
*/
	GraphAnalysis* ga = new GraphAnalysis(ac);
	ga->StartAnalysis(g->CFG_Ntk);
	ga->PrintAnalysisReuslt();
	//printf("in total, there are %d different operations used \n", OperationCounter.size());

	cout << "CFG_DEPTH: " << ac->CFG_DEPTH << "\n";
	cout << "CFG_idx: " << ac->CFG_idx << "\n";
	//return 1;
	Module* Mod = g->CFG_Ntk->makeLLVMModulefromCFGNtk();

	raw_ostream *OutbcFile;
	PassManager PM;

	raw_ostream *OutllFile;
	OutllFile =new raw_fd_ostream("test_out.ll", Err, raw_fd_ostream::F_Binary);
	verifyModule(*Mod, PrintMessageAction);

	PM.add(createPrintModulePass(OutllFile));

	PM.run(*Mod);
	cout << "Done\n";
}

