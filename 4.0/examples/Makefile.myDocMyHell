# Assume all .c files are independent source files
ifndef SRCS
	SRCS := $(shell ls *.c)
endif

# Assume all .h files are needed by all c files
# Also, we want it to fail silently as .h files aren't necessarily required
ifndef HEADERS
	HEADERS := $(shell ls *.h 2> /dev/null)
endif
# Each .c file will be compiled to its own .bc file by the frontend target(s)
ifndef FEOBJS
	FEOBJS := $(SRCS:.c=.fe.bc)
endif

# By default, name the output files by the directory name
#ifndef NAME
#	NAME := $(shell basename `pwd`)
#endif

# Each .c file will be compiled to its own .bc file
ifdef LINK
	OBJS := $(SRCS:.c=.hw.bc)
	TIGEROBJS := $(SRCS:.c=.sw.bc)
	ARMOBJS := $(SRCS:.c=.arm.sw.bc)
endif

#leandro - messing with loop pipelining
ifeq ($(CUSTOM_MODULE_SCHEDULING),1)
	PIPELINE_OPT_FLAGS = -load=$(LIB_DIR)LLVMLeandro.so $(LEGUP_TCL_FILES)
	LOOPSELECT_OPT_FLAGS = -load=$(LIB_DIR)LLVMLeandro.so $(LEGUP_TCL_FILES)
ifeq ($(NO_INLINE),1)
	PIPELINE_OPT_FLAGS += -disable-inlining
	LOOPSELECT_OPT_FLAGS += -disable-inlining
	OPT_FLAGS += -disable-inlining
endif
ifeq ($(NO_OPT),1)
	PIPELINE_OPT_FLAGS += -disable-opt
	LOOPSELECT_OPT_FLAGS += -disable-opt
	OPT_FLAGS += -disable-opt
endif
else # ILP_MODULE_SCHEDULING
	PIPELINE_OPT_FLAGS = $(OPT_FLAGS)
endif #if CUSTOM_MODULE_SCHEDULING

# make sure all is the default target, and not something from Makefile.aux
default: $(OVERRIDE)all

include $(LEVEL)/Makefile.config
include $(LEVEL)/Makefile.ancillary
include $(LEVEL)/Makefile.aux
include $(LEVEL)/Makefile.private

################################################################################
# Begin targets
################################################################################

# set $OVERRIDE if you'd like to change the 'all' target.
# see phi/Makefile
$(OVERRIDE)all: $(OBJS)
ifndef DEVICE_FAMILY
	$(shell $(FPGA_BOARD_CMD))
	$(error 'LegUp Error!')
endif # DEVICE_FAMILY

ifndef LINK
	echo name is: $(NAME)
	# annotate loop labels
	$(LEVEL)/mark_labels.pl $(NAME).c > $(NAME)_labeled.c

	# produces pre-link time optimization binary bitcode: $(NAME).prelto.bc
	$(FRONT_END) $(NAME)_labeled.c -emit-llvm -c $(CFLAG) $(CLANG_FLAG) -o $(NAME).prelto.1.bc
	$(LLVM_HOME)llvm-dis $(NAME).prelto.1.bc

#ifdef UNROLL
	#$(LLVM_HOME)opt -mem2reg -loops -loop-simplify -loop-unroll $(UNROLL) < $(NAME).prelto.1.bc > $(NAME).prelto.2.bc
#else # UNROLL
	$(LLVM_HOME)opt -mem2reg -loops -loop-simplify < $(NAME).prelto.1.bc > $(NAME).prelto.2.bc
#endif # UNROLL
	cp $(NAME).prelto.2.bc $(NAME).prelto.linked.bc
else  # LINK
	$(LLVM_HOME)llvm-link $(LDFLAG) $(OBJS) -o $(NAME).prelto.linked.bc
endif # LINK
	@echo '\n\n\n'
	@echo $(OPT_FLAGS)
	@echo '\n\n\n'
	# link-time optimizations may produce llvm mem-family intrinsics
	$(LLVM_HOME)opt $(OPT_FLAGS) -std-link-opts < $(NAME).prelto.linked.bc -o $(NAME).prelto.linked.1.bc

	# performs intrinsic lowering so that the linker may be optimized
	$(LLVM_HOME)opt $(OPT_FLAGS) -legup-prelto < $(NAME).prelto.linked.1.bc > $(NAME).prelto.6.bc

	# perform link-time optimizations
	$(LLVM_HOME)opt $(OPT_FLAGS) -std-link-opts < $(NAME).prelto.6.bc -o $(NAME).prelto.bc
	# produces $(NAME).bc binary bitcode
	$(LLVM_HOME)llvm-link $(LDFLAG) $(NAME).prelto.bc $(LEVEL)/lib/llvm/liblegup.bc $(LEVEL)/lib/llvm/libm.bc -o $(NAME).postlto.6.bc
	# remove all unused functions from linking with liblegup and libm
	$(LLVM_HOME)opt -internalize-public-api-list=main -internalize -globaldce $(NAME).postlto.6.bc -o $(NAME).postlto.8.bc

	# perform link-time optimizations
ifeq ($(DEBUG_KEEP_VARS_IN_MEM),1)
	$(LLVM_HOME)opt $(OPT_FLAGS) -std-link-opts < $(NAME).postlto.8.bc -o $(NAME).postlto.bc
else # DEBUG_KEEP_VARS_IN_MEM
	$(LLVM_HOME)opt $(OPT_FLAGS) -instcombine -std-link-opts < $(NAME).postlto.8.bc -o $(NAME).postlto.bc
endif # DEBUG_KEEP_VARS_IN_MEM

# NOTE: These extra passes help the loop pipelining benchmarks somewhat
#$(LLVM_HOME)opt $(OPT_FLAGS) -std-link-opts -instcombine -loop-rotate -loop-unroll < $(NAME).postlto.8.bc -o $(NAME).postlto.bc
	# iterative modulo scheduling

#this is the command that aplies loop pipelining
#$(LLVM_HOME)opt $(PIPELINE_OPT_FLAGS) -basicaa -loop-simplify -indvars2 $(COMBINE_BB_PASS) -loop-pipeline $(NAME).postlto.bc -o $(NAME).1.bc

#$(LLVM_HOME)opt $(PIPELINE_OPT_FLAGS) -basicaa -loop-simplify -indvars2 $(COMBINE_BB_PASS) -loop-select $(NAME).postlto.bc -o $(NAME).2.bc

	$(LLVM_HOME)llvm-dis $(NAME).prelto.linked.bc
	$(LLVM_HOME)llvm-dis $(NAME).prelto.linked.1.bc
	$(LLVM_HOME)llvm-dis $(NAME).prelto.6.bc
	$(LLVM_HOME)llvm-dis $(NAME).prelto.bc
	$(LLVM_HOME)llvm-dis $(NAME).postlto.bc
	$(LLVM_HOME)llvm-dis $(NAME).postlto.6.bc
	$(LLVM_HOME)llvm-dis $(NAME).postlto.8.bc

	$(LLVM_HOME)opt $(PIPELINE_OPT_FLAGS) -basicaa -loop-simplify -indvars2 $(COMBINE_BB_PASS) -loop-pipeline $(NAME).postlto.bc -o $(NAME).1.bc

ifeq ($(DEBUG_KEEP_VARS_IN_MEM),1)
	$(LLVM_HOME)opt $(OPT_FLAGS) $(NAME).1.bc -o $(NAME).bc
else # DEBUG_KEEP_VARS_IN_MEM
	$(LLVM_HOME)opt $(OPT_FLAGS) -instcombine $(NAME).1.bc -o $(NAME).bc
endif # DEBUG_KEEP_VARS_IN_MEM

	# produces textual bitcodes: $(NAME).prelto.1.ll $(NAME).prelto.ll $(NAME).ll
	$(LLVM_HOME)llvm-dis $(NAME).1.bc
	#$(LLVM_HOME)llvm-dis $(NAME).2.bc
	$(LLVM_HOME)llvm-dis $(NAME).bc

	# produces verilog: $(NAME).v
	$(LLVM_HOME)llc $(LLC_FLAGS) -march=v $(NAME).bc -o $(VFILE)

outputDirs: cleanall
	mkdir -p ir_out

################################################################################
# Extract loops and info for later fast selection
################################################################################
singleLoopFastDSE: $(OBJS) outputDirs
ifndef DEVICE_FAMILY
	$(shell $(FPGA_BOARD_CMD))
	$(error 'LegUp Error!')
endif # DEVICE_FAMILY

ifndef LINK
	$(LEVEL)/mark_labels.pl $(NAME).c > ir_out/$(NAME)_labeled.c
ifeq ($(LLVM_PROFILE),1)
	cp -f ir_out/$(NAME).c ir_out/$(NAME)_labeled.c
endif # LLVM_PROFILE
	$(FRONT_END) ir_out/$(NAME)_labeled.c -emit-llvm -c $(CFLAG) $(CLANG_FLAG) -o ir_out/$(NAME).prelto.1.bc
	cp -f ir_out/$(NAME).prelto.1.bc ir_out/$(NAME).prelto.cv.bc
ifdef UNROLL
	$(LLVM_HOME)opt -mem2reg -loops -loop-simplify -loop-unroll $(UNROLL) < ir_out/$(NAME).prelto.cv.bc > ir_out/$(NAME).prelto.2.bc
else # UNROLL
ifeq ($(DEBUG_KEEP_VARS_IN_MEM),1)
	$(LLVM_HOME)opt -loops -loop-simplify < ir_out/$(NAME).prelto.cv.bc > ir_out/$(NAME).prelto.2.bc
else  # DEBUG_KEEP_VARS_IN_MEM
	$(LLVM_HOME)opt -mem2reg -loops -loop-simplify < ir_out/$(NAME).prelto.cv.bc > ir_out/$(NAME).prelto.2.bc
endif # DEBUG_KEEP_VARS_IN_MEM
endif # UNROLL
	cp ir_out/$(NAME).prelto.2.bc ir_out/$(NAME).prelto.linked.bc
else  # LINK
	$(LLVM_HOME)llvm-link $(LDFLAG) $(OBJS) -o ir_out/$(NAME).prelto.linked.bc
endif # LINK

	$(LLVM_HOME)opt $(OPT_FLAGS) -std-link-opts < ir_out/$(NAME).prelto.linked.bc -o ir_out/$(NAME).prelto.linked.1.bc
	$(LLVM_HOME)opt $(OPT_FLAGS) -legup-prelto < ir_out/$(NAME).prelto.linked.1.bc > ir_out/$(NAME).prelto.6.bc
	$(LLVM_HOME)opt $(OPT_FLAGS) -std-link-opts < ir_out/$(NAME).prelto.6.bc -o ir_out/$(NAME).prelto.bc
	$(LLVM_HOME)llvm-link $(LDFLAG) ir_out/$(NAME).prelto.bc $(LEVEL)/lib/llvm/liblegup.bc $(LEVEL)/lib/llvm/libm.bc -o ir_out/$(NAME).postlto.6.bc
	$(LLVM_HOME)opt -internalize-public-api-list=main -internalize -globaldce ir_out/$(NAME).postlto.6.bc -o ir_out/$(NAME).postlto.8.bc

	# perform link-time optimizations
ifeq ($(DEBUG_KEEP_VARS_IN_MEM),1)
	$(LLVM_HOME)opt $(OPT_FLAGS) -std-link-opts < ir_out/$(NAME).postlto.8.bc -o ir_out/$(NAME).postlto.bc
else # DEBUG_KEEP_VARS_IN_MEM
	$(LLVM_HOME)opt $(OPT_FLAGS) -instcombine -std-link-opts < ir_out/$(NAME).postlto.8.bc -o ir_out/$(NAME).postlto.bc
endif # DEBUG_KEEP_VARS_IN_MEM

	# iterative modulo scheduling
	$(LLVM_HOME)opt $(LOOPSELECT_OPT_FLAGS) -basicaa -loop-simplify -indvars2 $(COMBINE_BB_PASS) -loop-fast-dse ir_out/$(NAME).postlto.bc -o ir_out/$(NAME).1.bc

	#$(LLVM_HOME)llvm-dis ir_out/$(NAME).1.bc
	#$(LLVM_HOME)llvm-dis ir_out/$(NAME).2.bc

	#-------------------------------------------------------------------
	#_---------- here we start compiling loops ---------------------

ifndef LEGUPHOME
	$(error LegUP home is missing! Please add "export LEGUPHOME=<LegUP dir>" in your bashrc)
endif

	#compiles each hardware according to the respective config
	$(eval LOOP_FOLDERS:=./fast_loops_out/*)
	@echo $(LOOP_FOLDERS)

	#TODO loop-select creates an module.bc file, which has already passed through all opt passes, this file is used to compile with each different config. This is generating errors in the modelsim.
	#TODO we are hotfixing this, but the loop wrapper inplementation should solve this. I hope.
	for mkfile in  $(LOOP_FOLDERS) ; do \
		echo cp $(NAME).c $$mkfile/module.c; \
		cp $(NAME).c $$mkfile/module.c;	 \
	done

	#read -p "Press any key to continue... " -n1 -s

	#compile each config effectivly
	for mkfile in  $(LOOP_FOLDERS) ; do \
		$(MAKE) --ignore-errors -C $$mkfile; \
	done

	#first, get only folders and configs that generated hardware
	$(eval LOOP_BUILTS:=./fast_loops_out/*/out.config*.tcl/hardware_estimation.mat	)

	#TODO gonna have to run this in the end
	octave $(LEGUPHOME)/examples/loop_selection.m $(LOOP_BUILTS)
	octave $(LEGUPHOME)/examples/cluster_correlation.m $(LOOP_BUILTS)

################################################################################
# Extract loops and info for later Exhaustive selection
################################################################################
singleLoopExhaustiveDSE: $(OBJS) outputDirs
ifndef DEVICE_FAMILY
	$(shell $(FPGA_BOARD_CMD))
	$(error 'LegUp Error!')
endif # DEVICE_FAMILY

ifndef LINK
	$(LEVEL)/mark_labels.pl $(NAME).c > ir_out/$(NAME)_labeled.c
ifeq ($(LLVM_PROFILE),1)
	cp -f ir_out/$(NAME).c ir_out/$(NAME)_labeled.c
endif # LLVM_PROFILE
	$(FRONT_END) ir_out/$(NAME)_labeled.c -emit-llvm -c $(CFLAG) $(CLANG_FLAG) -o ir_out/$(NAME).prelto.1.bc
	cp -f ir_out/$(NAME).prelto.1.bc ir_out/$(NAME).prelto.cv.bc
ifdef UNROLL
	$(LLVM_HOME)opt -mem2reg -loops -loop-simplify -loop-unroll $(UNROLL) < ir_out/$(NAME).prelto.cv.bc > ir_out/$(NAME).prelto.2.bc
else # UNROLL
ifeq ($(DEBUG_KEEP_VARS_IN_MEM),1)
	$(LLVM_HOME)opt -loops -loop-simplify < ir_out/$(NAME).prelto.cv.bc > ir_out/$(NAME).prelto.2.bc
else  # DEBUG_KEEP_VARS_IN_MEM
	$(LLVM_HOME)opt -mem2reg -loops -loop-simplify < ir_out/$(NAME).prelto.cv.bc > ir_out/$(NAME).prelto.2.bc
endif # DEBUG_KEEP_VARS_IN_MEM
endif # UNROLL
	cp ir_out/$(NAME).prelto.2.bc ir_out/$(NAME).prelto.linked.bc
else  # LINK
	$(LLVM_HOME)llvm-link $(LDFLAG) $(OBJS) -o ir_out/$(NAME).prelto.linked.bc
endif # LINK

	$(LLVM_HOME)opt $(OPT_FLAGS) -std-link-opts < ir_out/$(NAME).prelto.linked.bc -o ir_out/$(NAME).prelto.linked.1.bc
	$(LLVM_HOME)opt $(OPT_FLAGS) -legup-prelto < ir_out/$(NAME).prelto.linked.1.bc > ir_out/$(NAME).prelto.6.bc
	$(LLVM_HOME)opt $(OPT_FLAGS) -std-link-opts < ir_out/$(NAME).prelto.6.bc -o ir_out/$(NAME).prelto.bc
	$(LLVM_HOME)llvm-link $(LDFLAG) ir_out/$(NAME).prelto.bc $(LEVEL)/lib/llvm/liblegup.bc $(LEVEL)/lib/llvm/libm.bc -o ir_out/$(NAME).postlto.6.bc
	$(LLVM_HOME)opt -internalize-public-api-list=main -internalize -globaldce ir_out/$(NAME).postlto.6.bc -o ir_out/$(NAME).postlto.8.bc

	# perform link-time optimizations
ifeq ($(DEBUG_KEEP_VARS_IN_MEM),1)
	$(LLVM_HOME)opt $(OPT_FLAGS) -std-link-opts < ir_out/$(NAME).postlto.8.bc -o ir_out/$(NAME).postlto.bc
else # DEBUG_KEEP_VARS_IN_MEM
	$(LLVM_HOME)opt $(OPT_FLAGS) -instcombine -std-link-opts < ir_out/$(NAME).postlto.8.bc -o ir_out/$(NAME).postlto.bc
endif # DEBUG_KEEP_VARS_IN_MEM

	# iterative modulo scheduling
	$(LLVM_HOME)opt $(LOOPSELECT_OPT_FLAGS) -basicaa -loop-simplify -indvars2 $(COMBINE_BB_PASS) -loop-full-dse ir_out/$(NAME).postlto.bc -o ir_out/$(NAME).1.bc

	#$(LLVM_HOME)llvm-dis ir_out/$(NAME).1.bc
	#$(LLVM_HOME)llvm-dis ir_out/$(NAME).2.bc

	#-------------------------------------------------------------------
	#_---------- here we start compiling all loops ---------------------

	# produces verilog: $(NAME).v
	#$(LLVM_HOME)llc $(LLC_FLAGS) -march=v ir_out/$(NAME).bc -o $(VFILE)
ifndef LEGUPHOME
	$(error LegUP home is missing! Please add "export LEGUPHOME=<LegUP dir>" in your bashrc)
endif

	#compiles each hardware according to the respective config
	$(eval LOOP_FOLDERS:=./loops_out/*)
	@echo $(LOOP_FOLDERS)

	#TODO loop-select creates an module.bc file, which has already passed through all opt passes, this file is used to compile with each different config. This is generating errors in the modelsim.
	#TODO we are hotfixing this, but the loop wrapper inplementation should solve this. I hope.
	for mkfile in  $(LOOP_FOLDERS) ; do \
		echo cp $(NAME).c $$mkfile/module.c; \
		cp $(NAME).c $$mkfile/module.c;	 \
	done

	#read -p "Press any key to continue... " -n1 -s

	#compile each config effectivly
	for mkfile in  $(LOOP_FOLDERS) ; do \
		$(MAKE) --ignore-errors -C $$mkfile; \
	done

	#first, get only folders and configs that generated hardware
	$(eval LOOP_BUILTS:=./loops_out/*/out.config*.tcl/hardware_estimation.mat	)
	octave $(LEGUPHOME)/examples/loop_selection.m $(LOOP_BUILTS)
	octave $(LEGUPHOME)/examples/cluster_correlation.m $(LOOP_BUILTS)

################################################################################
# Quartus stuff
################################################################################
# create a Quartus II project
p: $(VFILE)
ifeq ($(XILINX),1)
	xtclsh $(LEVEL)/setup_proj_xilinx.tcl $(FAMILY) $(FPGA_BOARD) $(NAME) $(TOP_LEVEL_MODULE) $(DEBUGGER)
else
ifeq ($(MULTICYCLE_CONSTRAINTS),1)
	# create an sdc file with a 2ns clock period
	echo "create_clock -period 2 -name clk [get_ports clk]" > $(NAME).sdc
	echo "create_clock -period 1 -name clk2x [get_ports clk2x]" >> $(NAME).sdc
	echo "create_clock -period 2 -name OSC_50_BANK2 [get_ports OSC_50_BANK2]" >> $(NAME).sdc
	echo "derive_pll_clocks" >> $(NAME).sdc
	echo "derive_clock_uncertainty" >> $(NAME).sdc
	# create an sdc file with a 1ns clock period and multi-cycle constraints
	@cp llvm_prof_multicycle_constraints.sdc llvm_prof_multicycle_constraints_no_through_constraints.sdc 2>/dev/null ||:
	python $(LEVEL)/multi_cycle_remove_through_constraints.py llvm_prof_multicycle_constraints.sdc llvm_prof_multicycle_constraints_no_through_constraints.sdc src_dst_pairs_with_through_constraints.txt pairs_whose_through_constraints_must_be_removed.txt
	echo '# From llvm_prof_multicycle_constraints.sdc:' >> $(NAME).sdc
	# If a llvm_prof_multicycle_constraints.sdc file exists, concatenate
	# its contents to the .sdc file as well
	@cat llvm_prof_multicycle_constraints_no_through_constraints.sdc >> $(NAME).sdc 2>/dev/null ||:
	# Finally, run a script to fix incorrect signal names
else
	# create an sdc file with a 1ns clock period
	echo "create_clock -period 2 -name clk [get_ports clk]" > $(NAME).sdc
	echo "create_clock -period 1 -name clk2x [get_ports clk2x]" >> $(NAME).sdc
	echo "create_clock -period 2 -name OSC_50_BANK2 [get_ports OSC_50_BANK2]" >> $(NAME).sdc
	echo "derive_pll_clocks" >> $(NAME).sdc
	echo "derive_clock_uncertainty" >> $(NAME).sdc
endif

ifeq ($(TIMING_ANALYSIS_DATAPATH_ONLY),1)
	# Add false path constraints to non-data paths
	echo "" >> $(NAME).sdc
	echo "# Adding False Path Constraints" >> $(NAME).sdc
	echo "set_false_path -from [get_registers {*memory_controller*}] -to [get_registers {*}]" >> $(NAME).sdc
	echo "set_false_path -from [get_registers {*}] -to [get_registers {*memory_controller*}]" >> $(NAME).sdc
	echo "set_false_path -from [get_registers {*cur_state*}] -to [get_registers {*}]" >> $(NAME).sdc
	echo "set_false_path -from [get_registers {*}] -to [get_registers {*cur_state*}]" >> $(NAME).sdc
	echo "set_false_path -from [get_registers {*ram*}] -to [get_registers {*}]" >> $(NAME).sdc
	echo "set_false_path -from [get_registers {*}] -to [get_registers {*ram*}]" >> $(NAME).sdc
	echo "set_false_path -from [get_registers {*DFF*}] -to [get_registers {*}]" >> $(NAME).sdc
	echo "set_false_path -from [get_registers {*}] -to [get_registers {*DFF*}]" >> $(NAME).sdc
	echo "set_false_path -from [get_registers {*_phi_temp*}] -to [get_registers {*}]" >> $(NAME).sdc
endif

ifeq ($(DEBUGGER),1)
#	quartus_sh -t $(LEVEL)/setup_proj.tcl $(FAMILY) $(NAME) $(TOP_LEVEL_MODULE) $(DBG_DIR)
	quartus_sh -t $(LEVEL)/setup_proj.tcl $(FAMILY) $(FPGA_BOARD) $(NAME) $(TOP_LEVEL_MODULE) $(DBG_DIR)
else
#	quartus_sh -t $(LEVEL)/setup_proj.tcl $(FAMILY) $(NAME) $(TOP_LEVEL_MODULE)
	quartus_sh -t $(LEVEL)/setup_proj.tcl $(FAMILY) $(FPGA_BOARD) $(NAME) $(TOP_LEVEL_MODULE)
endif
endif

ifeq ($(MULTICYCLE_CONSTRAINTS),1)
	@cat llvm_prof_multicycle_constraints.qsf >> top.qsf 2>/dev/null ||:
endif

# Run FPGA mapper
q: $(VFILE)
ifeq ($(XILINX),1)
	xtclsh <<< "project open top; process run \"Synthesize - XST\" -force rerun_all; if {[lsearch [list \"out_of_date\" \"errors\" \"never_run\" \"aborted\"] [string tolower [process get \"Synthesize - XST\" status]]] >= 0} {exit 1} "
else
	quartus_map $(LEGUP_QUARTUS_64BIT) top -l $(VERILOG_LIB_DIR) --source=$(VFILE) --family=$(FAMILY)
endif

# Run full FPGA compilation flow
f: $(VFILE)
ifeq ($(XILINX),1)
	xtclsh <<< "project open top; process run \"Generate Programming File\" -force rerun_all; if {[lsearch [list \"out_of_date\" \"errors\" \"never_run\" \"aborted\"] [string tolower [process get \"Generate Programming File\" status]]] >= 0} {exit 1} "
else
	quartus_sh $(LEGUP_QUARTUS_64BIT) --flow compile top
endif

v: $(VFILE)
	$(VLIB)
	vlog $(addprefix -v ,${VERILOG_LIBS}) $(VFILE)
	vlog $(addprefix -sv ,${SYSTEMVERILOG_LIBS})
	vsim $(VSIMFLAG) -c -do "run 7000000000000000ns; exit;" work.$(TEST_BENCH)



################################################################################
# Cleaning targets
################################################################################

cleannew:
	rm -rf $(OUTPUT_PATH)

cleantiger:
	rm -rf a.out *.bc *.dat *.dump *.elf *.o *.s *.src *.hash *.flist *.flist_lab *.emul.*
	rm -rf $(PROC_DIR)/work
	rm -rf $(PROC_DIR)/verilog_libs

cleanpcie:
	echo $(PROCESSOR)
	rm -rf pcie_tutorial legup_pcie_wrappers_generated.c legup_qsys_pcie_generated.tcl $(NAME)_sw $(NAME)_sw_memtest simulation_tb tb_master.v lib$(NAME).a legup_riffa.tar legup_riffa

cleanarm:
	rm -rf *.bin *.srec $(NAME)_jtag_uart.output

# "make clean" is run by the test suite -- do not delete Quartus or Modelsim files (use "make cleanall" instead)
clean: cleantiger cleanpcie cleanarm cleannew cleanprivate
	rm -rf *.ll *.mif $(VFILE) *.smsg *.ver lli.txt sim.txt *_hw.tcl legup_sopc.tcl legup_qsys.tcl legup_wrappers.c work *.log functions.list wave.do *.legup.rpt tiger *.dot *.csv *.tex parallelaccels.tcl $(NAME)_labeled.c genRAM.pl *.wlf *.qsf *.sdc *.txt *profile* *llvmprof* compile.tcl sim.tcl ModelsimListener.tcl Inspect.config init.tcl *.vstf board_programmed.txt *.native

# be careful: removes Quartus and Modelsim files
cleanall: clean
	rm -rf ir_out loops_out fast_loops_out plots
	rm -rf DetailedLegUPTiming DetailedModuleSDCSchedulingTime DegradedModuleSchedulerTimes
	rm -rf *.lp *.mps
	rm -rf db *.done incremental_db *.pin *.pof *.qpf *.qsf *.rpt *.smsg *.sof *.summary *.jdi transcript *.wlf work *.bc *.list *.txt *.trace hc_output *top_assignment_defaults.qdf
# Xilinx ISE files
	rm -rf *.ucf *.gise *.xise _xmsgs *.bgn *.bit *.xwbt *.bld *.cmd_log *.drc *.ncd *.lso *.map *.mrp *.ngm *.xrpt *.ngc *.ngd *.ngr *.pad *.par *.pcf *.prj *.ptwx *.stx *.xml *.syr *.twr *.twx *.unroutes *.ut *.xpi _ngo *.xst usage_statistics_webtalk.html webtalk_pn.xml xlnx_auto_0_xdb xst
	rm -rf $(PROC_DIR)/work
	rm -rf $(PROC_DIR)/verilog_libs
	rm -rf on_board

# end cleaning targets


################################################################################
# dependency targets
################################################################################
function:
	#hybridHwOnlyPass \
	$(LLVM_HOME)opt -legup-config=config.tcl $(OPT_FLAGS) -legup-hw-only < $(NAME).prelto.bc > $(NAME).prelto.hw.bc
	$(LLVM_HOME)llvm-dis $(NAME).prelto.hw.bc \
	hybridHWloweringLinking \
	HWVerilogbackend

################################################################################
# dependency targets
################################################################################

$(VFILE):
	make all

.PHONY: $(FULLNAME).$(PROC_ARCH).o
$(FULLNAME).$(PROC_ARCH).o: \
	create_output_directory \
	partition_code_for_sw_only \
	$(FULLNAME).elf

$(FULLNAME).o: $(FULLNAME).$(PROC_ARCH).o
	cp $< $@


# end dependency targets



###############################################################################
# Phony targets
###############################################################################

#.PHONY : $(OVERRIDE)all watch v p q f tiger tiger_prof tigersim tigersim_prof gprof emul emulwatch emultest emultrace cleanarm cleantiger clean cleanall hierarchy hybrid functionslist hybridwatch hybridwatch_hw benchmarkfiles copyTigerforHybrid hybridOmpFrontend hybridMIPSbackend profile_tiger_on_board profile_hybrid_on_board detail_instr_profile arm arm_sim

.PHONY: cleanprivate

# end phony targets
