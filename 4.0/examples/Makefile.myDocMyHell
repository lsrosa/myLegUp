# Assume all .c files are independent source files
ifndef SRCS
	SRCS := $(shell ls *.c)
endif

# Assume all .h files are needed by all c files
# Also, we want it to fail silently as .h files aren't necessarily required
ifndef HEADERS
	HEADERS := $(shell ls *.h 2> /dev/null)
endif
# Each .c file will be compiled to its own .bc file by the frontend target(s)
ifndef FEOBJS
	FEOBJS := $(SRCS:.c=.fe.bc)
endif

# By default, name the output files by the directory name
ifndef NAME
	NAME := $(shell basename `pwd`)
endif

# Each .c file will be compiled to its own .bc file
ifdef LINK
	OBJS := $(SRCS:.c=.hw.bc)
	TIGEROBJS := $(SRCS:.c=.sw.bc)
	ARMOBJS := $(SRCS:.c=.arm.sw.bc)
endif

#leandro - messing with loop pipelining
ifeq ($(CUSTOM_MODULE_SCHEDULING),1)
	PIPELINE_OPT_FLAGS = -load=$(LIB_DIR)LLVMLeandro.so $(LEGUP_TCL_FILES)
	LOOPSELECT_OPT_FLAGS = -load=$(LIB_DIR)LLVMLeandro.so $(LEGUP_TCL_FILES)
ifeq ($(NO_INLINE),1)
	PIPELINE_OPT_FLAGS += -disable-inlining
	LOOPSELECT_OPT_FLAGS += -disable-inlining
	OPT_FLAGS += -disable-inlining
endif
ifeq ($(NO_OPT),1)
	PIPELINE_OPT_FLAGS += -disable-opt
	LOOPSELECT_OPT_FLAGS += -disable-opt
	OPT_FLAGS += -disable-opt
endif
else # ILP_MODULE_SCHEDULING
	PIPELINE_OPT_FLAGS = $(OPT_FLAGS)
endif #if CUSTOM_MODULE_SCHEDULING

# make sure all is the default target, and not something from Makefile.aux
default: $(OVERRIDE)all

include $(LEVEL)/Makefile.config
include $(LEVEL)/Makefile.ancillary
include $(LEVEL)/Makefile.aux
include $(LEVEL)/Makefile.private

################################################################################
# Begin targets
################################################################################

# set $OVERRIDE if you'd like to change the 'all' target.
# see phi/Makefile
$(OVERRIDE)all: $(OBJS)
ifndef DEVICE_FAMILY
	$(shell $(FPGA_BOARD_CMD))
	$(error 'LegUp Error!')
endif # DEVICE_FAMILY

ifndef LINK
	# annotate loop labels
	$(LEVEL)/mark_labels.pl $(NAME).c > $(NAME)_labeled.c

	# produces pre-link time optimization binary bitcode: $(NAME).prelto.bc
	$(FRONT_END) $(NAME)_labeled.c -emit-llvm -c $(CFLAG) $(CLANG_FLAG) -o $(NAME).prelto.1.bc
	$(LLVM_HOME)llvm-dis $(NAME).prelto.1.bc

#ifdef UNROLL
	#$(LLVM_HOME)opt -mem2reg -loops -loop-simplify -loop-unroll $(UNROLL) < $(NAME).prelto.1.bc > $(NAME).prelto.2.bc
#else # UNROLL
	$(LLVM_HOME)opt -mem2reg -loops -loop-simplify < $(NAME).prelto.1.bc > $(NAME).prelto.2.bc
#endif # UNROLL
	cp $(NAME).prelto.2.bc $(NAME).prelto.linked.bc
else  # LINK
	$(LLVM_HOME)llvm-link $(LDFLAG) $(OBJS) -o $(NAME).prelto.linked.bc
endif # LINK
	@echo '\n\n\n'
	@echo $(OPT_FLAGS)
	@echo '\n\n\n'
	# link-time optimizations may produce llvm mem-family intrinsics
	$(LLVM_HOME)opt $(OPT_FLAGS) -std-link-opts < $(NAME).prelto.linked.bc -o $(NAME).prelto.linked.1.bc

	# performs intrinsic lowering so that the linker may be optimized
	$(LLVM_HOME)opt $(OPT_FLAGS) -legup-prelto < $(NAME).prelto.linked.1.bc > $(NAME).prelto.6.bc

	# perform link-time optimizations
	$(LLVM_HOME)opt $(OPT_FLAGS) -std-link-opts < $(NAME).prelto.6.bc -o $(NAME).prelto.bc
	# produces $(NAME).bc binary bitcode
	$(LLVM_HOME)llvm-link $(LDFLAG) $(NAME).prelto.bc $(LEVEL)/lib/llvm/liblegup.bc $(LEVEL)/lib/llvm/libm.bc -o $(NAME).postlto.6.bc
	# remove all unused functions from linking with liblegup and libm
	$(LLVM_HOME)opt -internalize-public-api-list=main -internalize -globaldce $(NAME).postlto.6.bc -o $(NAME).postlto.8.bc

	# perform link-time optimizations
ifeq ($(DEBUG_KEEP_VARS_IN_MEM),1)
	$(LLVM_HOME)opt $(OPT_FLAGS) -std-link-opts < $(NAME).postlto.8.bc -o $(NAME).postlto.bc
else # DEBUG_KEEP_VARS_IN_MEM
	$(LLVM_HOME)opt $(OPT_FLAGS) -instcombine -std-link-opts < $(NAME).postlto.8.bc -o $(NAME).postlto.bc
endif # DEBUG_KEEP_VARS_IN_MEM

# NOTE: These extra passes help the loop pipelining benchmarks somewhat
#$(LLVM_HOME)opt $(OPT_FLAGS) -std-link-opts -instcombine -loop-rotate -loop-unroll < $(NAME).postlto.8.bc -o $(NAME).postlto.bc
	# iterative modulo scheduling

#this is the command that aplies loop pipelining
#$(LLVM_HOME)opt $(PIPELINE_OPT_FLAGS) -basicaa -loop-simplify -indvars2 $(COMBINE_BB_PASS) -loop-pipeline $(NAME).postlto.bc -o $(NAME).1.bc

#$(LLVM_HOME)opt $(PIPELINE_OPT_FLAGS) -basicaa -loop-simplify -indvars2 $(COMBINE_BB_PASS) -loop-select $(NAME).postlto.bc -o $(NAME).2.bc

	$(LLVM_HOME)llvm-dis $(NAME).prelto.linked.bc
	$(LLVM_HOME)llvm-dis $(NAME).prelto.linked.1.bc
	$(LLVM_HOME)llvm-dis $(NAME).prelto.6.bc
	$(LLVM_HOME)llvm-dis $(NAME).prelto.bc
	$(LLVM_HOME)llvm-dis $(NAME).postlto.bc
	$(LLVM_HOME)llvm-dis $(NAME).postlto.6.bc
	$(LLVM_HOME)llvm-dis $(NAME).postlto.8.bc

	$(LLVM_HOME)opt $(PIPELINE_OPT_FLAGS) -basicaa -loop-simplify -indvars2 $(COMBINE_BB_PASS) -loop-pipeline $(NAME).postlto.bc -o $(NAME).1.bc

ifeq ($(DEBUG_KEEP_VARS_IN_MEM),1)
	$(LLVM_HOME)opt $(OPT_FLAGS) $(NAME).1.bc -o $(NAME).bc
else # DEBUG_KEEP_VARS_IN_MEM
	$(LLVM_HOME)opt $(OPT_FLAGS) -instcombine $(NAME).1.bc -o $(NAME).bc
endif # DEBUG_KEEP_VARS_IN_MEM

	# produces textual bitcodes: $(NAME).prelto.1.ll $(NAME).prelto.ll $(NAME).ll
	$(LLVM_HOME)llvm-dis $(NAME).1.bc
	#$(LLVM_HOME)llvm-dis $(NAME).2.bc
	$(LLVM_HOME)llvm-dis $(NAME).bc

	# produces verilog: $(NAME).v
	$(LLVM_HOME)llc $(LLC_FLAGS) -march=v $(NAME).bc -o $(VFILE)

################################################################################
# Extract loops and info for further selection
################################################################################
outputDirs: cleanall
	mkdir -p ir_out

# set $OVERRIDE if you'd like to change the 'all' target.
# see phi/Makefile
extracNests: $(OBJS) outputDirs
ifndef DEVICE_FAMILY
	$(shell $(FPGA_BOARD_CMD))
	$(error 'LegUp Error!')
endif # DEVICE_FAMILY

ifndef LINK
	$(LEVEL)/mark_labels.pl $(NAME).c > $(NAME)_labeled.c
	$(FRONT_END) $(NAME)_labeled.c -emit-llvm -c $(CFLAG) $(CLANG_FLAG) -o ir_out/$(NAME).prelto.1.bc
	#$(LLVM_HOME)llvm-dis ir_out/$(NAME).prelto.1.bc

	$(LLVM_HOME)opt -mem2reg -loops -loop-simplify < ir_out/$(NAME).prelto.1.bc > ir_out/$(NAME).prelto.2.bc
	cp ir_out/$(NAME).prelto.2.bc ir_out/$(NAME).prelto.linked.bc
else  # LINK
	$(LLVM_HOME)llvm-link $(LDFLAG) $(OBJS) -o ir_out/$(NAME).prelto.linked.bc
endif # LINK

	$(LLVM_HOME)opt $(OPT_FLAGS) -std-link-opts < ir_out/$(NAME).prelto.linked.bc -o ir_out/$(NAME).prelto.linked.1.bc
	$(LLVM_HOME)opt $(OPT_FLAGS) -legup-prelto < ir_out/$(NAME).prelto.linked.1.bc > ir_out/$(NAME).prelto.6.bc
	$(LLVM_HOME)opt $(OPT_FLAGS) -std-link-opts < ir_out/$(NAME).prelto.6.bc -o ir_out/$(NAME).prelto.bc
	$(LLVM_HOME)llvm-link $(LDFLAG) ir_out/$(NAME).prelto.bc $(LEVEL)/lib/llvm/liblegup.bc $(LEVEL)/lib/llvm/libm.bc -o ir_out/$(NAME).postlto.6.bc
	$(LLVM_HOME)opt -internalize-public-api-list=main -internalize -globaldce ir_out/$(NAME).postlto.6.bc -o ir_out/$(NAME).postlto.8.bc

ifeq ($(DEBUG_KEEP_VARS_IN_MEM),1)
	$(LLVM_HOME)opt $(OPT_FLAGS) -std-link-opts < ir_out/$(NAME).postlto.8.bc -o ir_out/$(NAME).postlto.bc
else # DEBUG_KEEP_VARS_IN_MEM
	$(LLVM_HOME)opt $(OPT_FLAGS) -instcombine -std-link-opts < ir_out/$(NAME).postlto.8.bc -o ir_out/$(NAME).postlto.bc
endif # DEBUG_KEEP_VARS_IN_MEM

	#$(LLVM_HOME)llvm-dis ir_out/$(NAME).prelto.linked.bc
	#$(LLVM_HOME)llvm-dis ir_out/$(NAME).prelto.linked.1.bc
	#$(LLVM_HOME)llvm-dis ir_out/$(NAME).prelto.6.bc
	#$(LLVM_HOME)llvm-dis ir_out/$(NAME).prelto.bc
	#$(LLVM_HOME)llvm-dis ir_out/$(NAME).postlto.bc
	#$(LLVM_HOME)llvm-dis ir_out/$(NAME).postlto.6.bc
	#$(LLVM_HOME)llvm-dis ir_out/$(NAME).postlto.8.bc

	#$(LLVM_HOME)opt $(LOOPSELECT_OPT_FLAGS) -basicaa -loop-simplify -indvars2 $(COMBINE_BB_PASS) -loop-pipeline ir_out/$(NAME).postlto.bc -o ir_out/$(NAME).1.bc
	#disble loop pipeline, I will try to apply it inside the loop select pass
	$(LLVM_HOME)opt $(OPT_FLAGS) -basicaa -loop-simplify -indvars2 $(COMBINE_BB_PASS) ir_out/$(NAME).postlto.bc -o ir_out/$(NAME).1.bc

	$(LLVM_HOME)opt $(OPT_FLAGS) ir_out/$(NAME).1.bc -o ir_out/$(NAME).bc
	$(LLVM_HOME)llvm-dis ir_out/$(NAME).bc

	$(LLVM_HOME)opt $(LOOPSELECT_OPT_FLAGS) -loop-select < ir_out/$(NAME).bc

	#$(LLVM_HOME)llvm-dis ir_out/$(NAME).1.bc
	#$(LLVM_HOME)llvm-dis ir_out/$(NAME).2.bc

	#-------------------------------------------------------------------
	#_---------- here we start compiling all loops ---------------------

	# produces verilog: $(NAME).v
	#$(LLVM_HOME)llc $(LLC_FLAGS) -march=v ir_out/$(NAME).bc -o $(VFILE)
ifndef LEGUPHOME
	$(error LegUP home is missing! Please add "export LEGUPHOME=<LegUP dir>" in your bashrc)
endif
	$(eval LOOP_MAKEFILES:=./loops_out/*)
	@echo $(LOOP_MAKEFILES)
	for mkfile in  $(LOOP_MAKEFILES) ; do \
			$(MAKE) -C $$mkfile ; \
	done
################################################################################
# Cleaning targets
################################################################################

cleannew:
	rm -rf $(OUTPUT_PATH)

cleantiger:
	rm -rf a.out *.bc *.dat *.dump *.elf *.o *.s *.src *.hash *.flist *.flist_lab *.emul.*
	rm -rf $(PROC_DIR)/work
	rm -rf $(PROC_DIR)/verilog_libs

cleanpcie:
	echo $(PROCESSOR)
	rm -rf pcie_tutorial legup_pcie_wrappers_generated.c legup_qsys_pcie_generated.tcl $(NAME)_sw $(NAME)_sw_memtest simulation_tb tb_master.v lib$(NAME).a legup_riffa.tar legup_riffa

cleanarm:
	rm -rf *.bin *.srec $(NAME)_jtag_uart.output

# "make clean" is run by the test suite -- do not delete Quartus or Modelsim files (use "make cleanall" instead)
clean: cleantiger cleanpcie cleanarm cleannew cleanprivate
	rm -rf *.ll *.mif $(VFILE) *.smsg *.ver lli.txt sim.txt *_hw.tcl legup_sopc.tcl legup_qsys.tcl legup_wrappers.c work *.log functions.list wave.do *.legup.rpt tiger *.dot *.csv *.tex parallelaccels.tcl $(NAME)_labeled.c genRAM.pl *.wlf *.qsf *.sdc *.txt *profile* *llvmprof* compile.tcl sim.tcl ModelsimListener.tcl Inspect.config init.tcl *.vstf board_programmed.txt *.native

# be careful: removes Quartus and Modelsim files
cleanall: clean

	rm -rf ir_out loops_out
	rm -rf DetailedLegUPTiming DetailedModuleSDCSchedulingTime DegradedModuleSchedulerTimes
	rm -rf *.lp *.mps
	rm -rf db *.done incremental_db *.pin *.pof *.qpf *.qsf *.rpt *.smsg *.sof *.summary *.jdi transcript *.wlf work *.bc *.list *.txt *.trace hc_output *top_assignment_defaults.qdf
# Xilinx ISE files
	rm -rf *.ucf *.gise *.xise _xmsgs *.bgn *.bit *.xwbt *.bld *.cmd_log *.drc *.ncd *.lso *.map *.mrp *.ngm *.xrpt *.ngc *.ngd *.ngr *.pad *.par *.pcf *.prj *.ptwx *.stx *.xml *.syr *.twr *.twx *.unroutes *.ut *.xpi _ngo *.xst usage_statistics_webtalk.html webtalk_pn.xml xlnx_auto_0_xdb xst
	rm -rf $(PROC_DIR)/work
	rm -rf $(PROC_DIR)/verilog_libs
	rm -rf on_board

# end cleaning targets


################################################################################
# dependency targets
################################################################################
function:
	#hybridHwOnlyPass \
	$(LLVM_HOME)opt -legup-config=config.tcl $(OPT_FLAGS) -legup-hw-only < $(NAME).prelto.bc > $(NAME).prelto.hw.bc
	$(LLVM_HOME)llvm-dis $(NAME).prelto.hw.bc \
	hybridHWloweringLinking \
	HWVerilogbackend

################################################################################
# dependency targets
################################################################################

$(VFILE):
	make all

.PHONY: $(FULLNAME).$(PROC_ARCH).o
$(FULLNAME).$(PROC_ARCH).o: \
	create_output_directory \
	partition_code_for_sw_only \
	$(FULLNAME).elf

$(FULLNAME).o: $(FULLNAME).$(PROC_ARCH).o
	cp $< $@


# end dependency targets



###############################################################################
# Phony targets
###############################################################################

.PHONY : $(OVERRIDE)all watch v p q f tiger tiger_prof tigersim tigersim_prof gprof emul emulwatch emultest emultrace cleanarm cleantiger clean cleanall hierarchy hybrid functionslist hybridwatch hybridwatch_hw benchmarkfiles copyTigerforHybrid hybridOmpFrontend hybridMIPSbackend profile_tiger_on_board profile_hybrid_on_board detail_instr_profile arm arm_sim
.PHONY: cleanprivate

# end phony targets
