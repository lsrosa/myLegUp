ifeq ($(CUSTOM_MODULE_SCHEDULING),1)
	PIPELINE_OPT_FLAGS = -load=$(LIB_DIR)LLVMLeandro.so $(LEGUP_TCL_FILES)
	LOOPSELECT_OPT_FLAGS = -load=$(LIB_DIR)LLVMLeandro.so $(LEGUP_TCL_FILES)
ifeq ($(NO_INLINE),1)
	PIPELINE_OPT_FLAGS += -disable-inlining
	LOOPSELECT_OPT_FLAGS += -disable-inlining
	OPT_FLAGS += -disable-inlining
endif
ifeq ($(NO_OPT),1)
	PIPELINE_OPT_FLAGS += -disable-opt
	LOOPSELECT_OPT_FLAGS += -disable-opt
	OPT_FLAGS += -disable-opt
endif
else # ILP_MODULE_SCHEDULING
	PIPELINE_OPT_FLAGS = $(OPT_FLAGS)
endif #if CUSTOM_MODULE_SCHEDULING

# make sure all is the default target, and not something from Makefile.aux
default: $(OVERRIDE)all

include $(LEVEL)/Makefile.config
include $(LEVEL)/Makefile.ancillary
include $(LEVEL)/Makefile.aux
include $(LEVEL)/Makefile.private

################################################################################
# Begin targets
################################################################################

# set $OVERRIDE if you'd like to change the 'all' target.
# see phi/Makefile
NAME=module
TARGET_DIRS=$(patsubst %,out.%,$(CONFIGS))
TARGETS=$(patsubst %,%/$(VFILE),$(TARGET_DIRS))

$(OVERRIDE)all: $(OBJS) $(TARGETS)
	@echo ready "=)"

out.%/$(VFILE):%
	@echo $< $@
	$(eval LOOPS_OUTDIR:=out.$<)
	export LOOPS_OUTDIR=$(LOOPS_OUTDIR)
	$(eval OPT_FLAGS+= -legup-config=$<)
	$(eval PIPELINE_OPT_FLAGS+= -legup-config=$<)
	$(eval LLC_FLAGS+= -legup-config=$<)
	mkdir -p $(LOOPS_OUTDIR)

#TODO we will have to remove this later

ifndef LINK
	$(LEVEL)/mark_labels.pl $(NAME).c > $(LOOPS_OUTDIR)/$(NAME)_labeled.c
ifeq ($(LLVM_PROFILE),1)
	cp -f $(LOOPS_OUTDIR)/$(NAME).c $(LOOPS_OUTDIR)/$(NAME)_labeled.c
endif # LLVM_PROFILE
	$(FRONT_END) $(LOOPS_OUTDIR)/$(NAME)_labeled.c -emit-llvm -c $(CFLAG) $(CLANG_FLAG) -o $(LOOPS_OUTDIR)/$(NAME).prelto.1.bc
	cp -f $(LOOPS_OUTDIR)/$(NAME).prelto.1.bc $(LOOPS_OUTDIR)/$(NAME).prelto.cv.bc
ifdef UNROLL
	$(LLVM_HOME)opt -mem2reg -loops -loop-simplify -loop-unroll $(UNROLL) < $(LOOPS_OUTDIR)/$(NAME).prelto.cv.bc > $(LOOPS_OUTDIR)/$(NAME).prelto.2.bc
else # UNROLL
ifeq ($(DEBUG_KEEP_VARS_IN_MEM),1)
	$(LLVM_HOME)opt -loops -loop-simplify < $(LOOPS_OUTDIR)/$(NAME).prelto.cv.bc > $(LOOPS_OUTDIR)/$(NAME).prelto.2.bc
else  # DEBUG_KEEP_VARS_IN_MEM
	$(LLVM_HOME)opt -mem2reg -loops -loop-simplify < $(LOOPS_OUTDIR)/$(NAME).prelto.cv.bc > $(LOOPS_OUTDIR)/$(NAME).prelto.2.bc
endif # DEBUG_KEEP_VARS_IN_MEM
endif # UNROLL
	cp $(LOOPS_OUTDIR)/$(NAME).prelto.2.bc $(LOOPS_OUTDIR)/$(NAME).prelto.linked.bc
else  # LINK
	$(LLVM_HOME)llvm-link $(LDFLAG) $(OBJS) -o $(LOOPS_OUTDIR)/$(NAME).prelto.linked.bc
endif # LINK

	$(LLVM_HOME)opt $(OPT_FLAGS) -std-link-opts < $(LOOPS_OUTDIR)/$(NAME).prelto.linked.bc -o $(LOOPS_OUTDIR)/$(NAME).prelto.linked.1.bc
	$(LLVM_HOME)opt $(OPT_FLAGS) -legup-prelto < $(LOOPS_OUTDIR)/$(NAME).prelto.linked.1.bc > $(LOOPS_OUTDIR)/$(NAME).prelto.6.bc
	$(LLVM_HOME)opt $(OPT_FLAGS) -std-link-opts < $(LOOPS_OUTDIR)/$(NAME).prelto.6.bc -o $(LOOPS_OUTDIR)/$(NAME).prelto.bc
	$(LLVM_HOME)llvm-link $(LDFLAG) $(LOOPS_OUTDIR)/$(NAME).prelto.bc $(LEVEL)/lib/llvm/liblegup.bc $(LEVEL)/lib/llvm/libm.bc -o $(LOOPS_OUTDIR)/$(NAME).postlto.6.bc
	$(LLVM_HOME)opt -internalize-public-api-list=main -internalize -globaldce $(LOOPS_OUTDIR)/$(NAME).postlto.6.bc -o $(LOOPS_OUTDIR)/$(NAME).postlto.8.bc

	# perform link-time optimizations
ifeq ($(DEBUG_KEEP_VARS_IN_MEM),1)
	$(LLVM_HOME)opt $(OPT_FLAGS) -std-link-opts < $(LOOPS_OUTDIR)/$(NAME).postlto.8.bc -o $(LOOPS_OUTDIR)/$(NAME).postlto.bc
else # DEBUG_KEEP_VARS_IN_MEM
	$(LLVM_HOME)opt $(OPT_FLAGS) -instcombine -std-link-opts < $(LOOPS_OUTDIR)/$(NAME).postlto.8.bc -o $(LOOPS_OUTDIR)/$(NAME).postlto.bc
endif # DEBUG_KEEP_VARS_IN_MEM

	# iterative modulo scheduling
	$(LLVM_HOME)opt $(PIPELINE_OPT_FLAGS) -basicaa -loop-simplify -indvars2 $(COMBINE_BB_PASS) -loop-pipeline $(LOOPS_OUTDIR)/$(NAME).postlto.bc -o $(LOOPS_OUTDIR)/$(NAME).1.bc

ifeq ($(DEBUG_KEEP_VARS_IN_MEM),1)
	$(LLVM_HOME)opt $(OPT_FLAGS) $(LOOPS_OUTDIR)/$(NAME).1.bc -o $(LOOPS_OUTDIR)/$(NAME).bc
else # DEBUG_KEEP_VARS_IN_MEM
	$(LLVM_HOME)opt $(OPT_FLAGS) -instcombine $(LOOPS_OUTDIR)/$(NAME).1.bc -o $(LOOPS_OUTDIR)/$(NAME).bc
endif # DEBUG_KEEP_VARS_IN_MEM

	#check if loop pipelining did not fail
	if [ -f ./$(LOOPS_OUTDIR)/$(NAME).bc ]; then \
 		$(LLVM_HOME)llc $(LLC_FLAGS) -march=v $(LOOPS_OUTDIR)/$(NAME).bc -o $(LOOPS_OUTDIR)/$(VFILE); \
	fi

	#read -p "Press any key to continue... " -n1 -s

	-mv *.dot *.rpt *.mif *.qsf *.sdc *.txt $(LOOPS_OUTDIR)
	-mv DetailedLegUPTiming $(LOOPS_OUTDIR)
	-mv DetailedModuleSDCSchedulingTime $(LOOPS_OUTDIR)
	-mv gantt* $(LOOPS_OUTDIR)
	-cp Makefile $(LOOPS_OUTDIR)
	-cp $< $(LOOPS_OUTDIR)
	#Compiles de design

ifndef LEGUPHOME
	$(error LegUP home is missing! Please add "export LEGUPHOME=<LegUP dir>" in your bashrc)
endif

	#we are using quartus map estimations as estimation for now
	#this is a bit slow, fairly precise but has may metrics modify_system_to_enable_profiling
	#TODO create better estimations
	if [ -f ./$(LOOPS_OUTDIR)/$(VFILE) ]; then \
		make -C $(LOOPS_OUTDIR) p; \
		make -C $(LOOPS_OUTDIR) q; \
		make -C $(LOOPS_OUTDIR) v; \
		octave $(LEGUPHOME)/examples/estimation.m $(LOOPS_OUTDIR)/top.map.rpt; \
		else \
		echo "C to V compilation failed"; \
		exit 1; \
	fi
	#make -C $(LOOPS_OUTDIR) f; else
	#read -p "Press any key to continue... " -n1 -s

################################################################################
# Cleaning targets
################################################################################

# create a Quartus II project
p: $(VFILE)
ifeq ($(XILINX),1)
	xtclsh $(LEVEL)/setup_proj_xilinx.tcl $(FAMILY) $(FPGA_BOARD) $(NAME) $(TOP_LEVEL_MODULE) $(DEBUGGER)
else
ifeq ($(MULTICYCLE_CONSTRAINTS),1)
	# create an sdc file with a 2ns clock period
	echo "create_clock -period 2 -name clk [get_ports clk]" > $(NAME).sdc
	echo "create_clock -period 1 -name clk2x [get_ports clk2x]" >> $(NAME).sdc
	echo "create_clock -period 2 -name OSC_50_BANK2 [get_ports OSC_50_BANK2]" >> $(NAME).sdc
	echo "derive_pll_clocks" >> $(NAME).sdc
	echo "derive_clock_uncertainty" >> $(NAME).sdc
	# create an sdc file with a 1ns clock period and multi-cycle constraints
	@cp llvm_prof_multicycle_constraints.sdc llvm_prof_multicycle_constraints_no_through_constraints.sdc 2>/dev/null ||:
	python $(LEVEL)/multi_cycle_remove_through_constraints.py llvm_prof_multicycle_constraints.sdc llvm_prof_multicycle_constraints_no_through_constraints.sdc src_dst_pairs_with_through_constraints.txt pairs_whose_through_constraints_must_be_removed.txt
	echo '# From llvm_prof_multicycle_constraints.sdc:' >> $(NAME).sdc
	# If a llvm_prof_multicycle_constraints.sdc file exists, concatenate
	# its contents to the .sdc file as well
	@cat llvm_prof_multicycle_constraints_no_through_constraints.sdc >> $(NAME).sdc 2>/dev/null ||:
	# Finally, run a script to fix incorrect signal names
else
	# create an sdc file with a 1ns clock period
	echo "create_clock -period 2 -name clk [get_ports clk]" > $(NAME).sdc
	echo "create_clock -period 1 -name clk2x [get_ports clk2x]" >> $(NAME).sdc
	echo "create_clock -period 2 -name OSC_50_BANK2 [get_ports OSC_50_BANK2]" >> $(NAME).sdc
	echo "derive_pll_clocks" >> $(NAME).sdc
	echo "derive_clock_uncertainty" >> $(NAME).sdc
endif

ifeq ($(TIMING_ANALYSIS_DATAPATH_ONLY),1)
	# Add false path constraints to non-data paths
	echo "" >> $(NAME).sdc
	echo "# Adding False Path Constraints" >> $(NAME).sdc
	echo "set_false_path -from [get_registers {*memory_controller*}] -to [get_registers {*}]" >> $(NAME).sdc
	echo "set_false_path -from [get_registers {*}] -to [get_registers {*memory_controller*}]" >> $(NAME).sdc
	echo "set_false_path -from [get_registers {*cur_state*}] -to [get_registers {*}]" >> $(NAME).sdc
	echo "set_false_path -from [get_registers {*}] -to [get_registers {*cur_state*}]" >> $(NAME).sdc
	echo "set_false_path -from [get_registers {*ram*}] -to [get_registers {*}]" >> $(NAME).sdc
	echo "set_false_path -from [get_registers {*}] -to [get_registers {*ram*}]" >> $(NAME).sdc
	echo "set_false_path -from [get_registers {*DFF*}] -to [get_registers {*}]" >> $(NAME).sdc
	echo "set_false_path -from [get_registers {*}] -to [get_registers {*DFF*}]" >> $(NAME).sdc
	echo "set_false_path -from [get_registers {*_phi_temp*}] -to [get_registers {*}]" >> $(NAME).sdc
endif

ifeq ($(DEBUGGER),1)
#	quartus_sh -t $(LEVEL)/setup_proj.tcl $(FAMILY) $(NAME) $(TOP_LEVEL_MODULE) $(DBG_DIR)
	quartus_sh -t $(LEVEL)/setup_proj.tcl $(FAMILY) $(FPGA_BOARD) $(NAME) $(TOP_LEVEL_MODULE) $(DBG_DIR)
else
#	quartus_sh -t $(LEVEL)/setup_proj.tcl $(FAMILY) $(NAME) $(TOP_LEVEL_MODULE)
	quartus_sh -t $(LEVEL)/setup_proj.tcl $(FAMILY) $(FPGA_BOARD) $(NAME) $(TOP_LEVEL_MODULE)
endif
endif

ifeq ($(MULTICYCLE_CONSTRAINTS),1)
	@cat llvm_prof_multicycle_constraints.qsf >> top.qsf 2>/dev/null ||:
endif

# Run FPGA mapper
q: $(VFILE)
ifeq ($(XILINX),1)
	xtclsh <<< "project open top; process run \"Synthesize - XST\" -force rerun_all; if {[lsearch [list \"out_of_date\" \"errors\" \"never_run\" \"aborted\"] [string tolower [process get \"Synthesize - XST\" status]]] >= 0} {exit 1} "
else
	quartus_map $(LEGUP_QUARTUS_64BIT) top -l $(VERILOG_LIB_DIR) --source=$(VFILE) --family=$(FAMILY)
endif

# Run full FPGA compilation flow
f: $(VFILE)
ifeq ($(XILINX),1)
	xtclsh <<< "project open top; process run \"Generate Programming File\" -force rerun_all; if {[lsearch [list \"out_of_date\" \"errors\" \"never_run\" \"aborted\"] [string tolower [process get \"Generate Programming File\" status]]] >= 0} {exit 1} "
else
	quartus_sh $(LEGUP_QUARTUS_64BIT) --flow compile top
endif

v: $(VFILE)
	$(VLIB)
	vlog $(addprefix -v ,${VERILOG_LIBS}) $(VFILE)
	vlog $(addprefix -sv ,${SYSTEMVERILOG_LIBS})
	vsim $(VSIMFLAG) -c -do "run 7000000000000000ns; exit;" work.$(TEST_BENCH)


cleannew:
	rm -rf $(OUTPUT_PATH)

cleantiger:
	rm -rf a.out *.bc *.dat *.dump *.elf *.o *.s *.src *.hash *.flist *.flist_lab *.emul.*
	rm -rf $(PROC_DIR)/work
	rm -rf $(PROC_DIR)/verilog_libs

cleanpcie:
	echo $(PROCESSOR)
	rm -rf pcie_tutorial legup_pcie_wrappers_generated.c legup_qsys_pcie_generated.tcl $(NAME)_sw $(NAME)_sw_memtest simulation_tb tb_master.v lib$(NAME).a legup_riffa.tar legup_riffa

cleanarm:
	rm -rf *.bin *.srec $(NAME)_jtag_uart.output

# "make clean" is run by the test suite -- do not delete Quartus or Modelsim files (use "make cleanall" instead)
clean: cleantiger cleanpcie cleanarm cleannew cleanprivate
	rm -rf *.ll *.mif $(VFILE) *.smsg *.ver lli.txt sim.txt *_hw.tcl legup_sopc.tcl legup_qsys.tcl legup_wrappers.c work *.log functions.list wave.do *.legup.rpt tiger *.dot *.csv *.tex parallelaccels.tcl $(NAME)_labeled.c genRAM.pl *.wlf *.qsf *.sdc *.txt *profile* *llvmprof* compile.tcl sim.tcl ModelsimListener.tcl Inspect.config init.tcl *.vstf board_programmed.txt *.native

# be careful: removes Quartus and Modelsim files
cleanall: clean
	rm -rf loops_out
	rm -rf out.config*.tcl
	rm -rf ir_out loops_out
	rm -rf DetailedLegUPTiming DetailedModuleSDCSchedulingTime DegradedModuleSchedulerTimes
	rm -rf *.lp *.mps
	rm -rf db *.done incremental_db *.pin *.pof *.qpf *.qsf *.rpt *.smsg *.sof *.summary *.jdi transcript *.wlf work *.bc *.list *.txt *.trace hc_output *top_assignment_defaults.qdf
# Xilinx ISE files
	rm -rf *.ucf *.gise *.xise _xmsgs *.bgn *.bit *.xwbt *.bld *.cmd_log *.drc *.ncd *.lso *.map *.mrp *.ngm *.xrpt *.ngc *.ngd *.ngr *.pad *.par *.pcf *.prj *.ptwx *.stx *.xml *.syr *.twr *.twx *.unroutes *.ut *.xpi _ngo *.xst usage_statistics_webtalk.html webtalk_pn.xml xlnx_auto_0_xdb xst
	rm -rf $(PROC_DIR)/work
	rm -rf $(PROC_DIR)/verilog_libs
	rm -rf on_board

# end cleaning targets


################################################################################
# dependency targets
################################################################################
function:
	#hybridHwOnlyPass \
	$(LLVM_HOME)opt -legup-config=config.tcl $(OPT_FLAGS) -legup-hw-only < $(NAME).prelto.bc > $(NAME).prelto.hw.bc
	$(LLVM_HOME)llvm-dis $(NAME).prelto.hw.bc \
	hybridHWloweringLinking \
	HWVerilogbackend

################################################################################
# dependency targets
################################################################################

$(VFILE):
	make all

.PHONY: $(FULLNAME).$(PROC_ARCH).o
$(FULLNAME).$(PROC_ARCH).o: \
	create_output_directory \
	partition_code_for_sw_only \
	$(FULLNAME).elf

$(FULLNAME).o: $(FULLNAME).$(PROC_ARCH).o
	cp $< $@


# end dependency targets



###############################################################################
# Phony targets
###############################################################################

.PHONY : $(OVERRIDE)all watch v p q f tiger tiger_prof tigersim tigersim_prof gprof emul emulwatch emultest emultrace cleanarm cleantiger clean cleanall hierarchy hybrid functionslist hybridwatch hybridwatch_hw benchmarkfiles copyTigerforHybrid hybridOmpFrontend hybridMIPSbackend profile_tiger_on_board profile_hybrid_on_board detail_instr_profile arm arm_sim
.PHONY: cleanprivate

# end phony targets
